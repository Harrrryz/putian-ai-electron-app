# Codex 执行计划 (ExecPlans)

本文档描述了“执行计划”（ExecPlan）的要求。ExecPlan 是一份设计文档，编码智能体（coding agent）可以遵循它来交付可工作的特性或系统变更。请将读者视为对本代码库一无所知的初学者：他们只有当前的工作目录树和你提供的这份 ExecPlan 文件。这里没有关于之前计划的记忆，也没有外部上下文。

## 如何使用 ExecPlans 和 PLANS.md

在**编写**可执行规范（ExecPlan）时，请**严格**遵守 `PLANS.md`。如果该文件不在你的上下文中，请通读完整的 `PLANS.md` 文件以刷新记忆。阅读源材料时要通过仔细（甚至反复阅读）以生成准确的规范。创建规范时，从骨架开始，随着研究的深入逐步充实内容。

在**实施**可执行规范（ExecPlan）时，不要询问用户“下一步做什么”；直接推进到下一个里程碑。保持所有章节均为最新状态，在每个停止点添加或拆分列表条目，明确说明已取得的进展和下一步计划。自主解决歧义，并频繁提交代码。

在**讨论**可执行规范（ExecPlan）时，将决策记录在规范中的日志里，留作后续参考；任何对规范的修改都必须有清晰明确的原因。ExecPlan 是**动态文档（living document）**，应该始终能够仅凭 ExecPlan 而无需其他工作即可重新开始。

在**研究**具有挑战性的需求或存在重大未知的的设计时，利用里程碑来实现概念验证（PoC）、“玩具级实现”等，以验证用户的提议是否可行。通过查找或获取库的源代码进行深入研究，并包含原型以指导更完整的实现。

## 要求

**不可协商的要求 (NON-NEGOTIABLE REQUIREMENTS)：**

* 每个 ExecPlan 必须是**完全自包含的**。自包含意味着在其当前形式下，它包含了新手成功所需的所有知识和指令。
* 每个 ExecPlan 都是一份**动态文档**。贡献者需要在取得进展、通过发现获得新知以及最终确定设计决策时对其进行修订。每次修订必须保持完全自包含。
* 每个 ExecPlan 必须能让一个完全的新手在没有本仓库先验知识的情况下，端到端地实现该功能。
* 每个 ExecPlan 必须产生**可演示的工作行为**，而不仅仅是为了“满足定义”的代码变更。
* 每个 ExecPlan 必须用通俗易懂的语言定义每一个专业术语，否则就不要使用该术语。

**目的和意图至上**。首先用几句话解释这项工作从用户的角度看为什么重要：变更后用户能做哪些之前做不到的事，以及如何看到它的效果。然后引导读者通过确切的步骤来实现该结果，包括编辑什么、运行什么以及他们应该观察到什么。

执行你计划的智能体可以列出文件、读取文件、搜索、运行项目和运行测试。它不知道任何先前的上下文，也无法推断你在早期里程碑中的意图。重复你所依赖的任何假设。**不要**指向外部博客或文档；如果需要知识，请用你自己的话将其嵌入到计划本身中。如果一个 ExecPlan 建立在先前的 ExecPlan 之上且该文件已检入代码库，请通过引用包含它。如果没有，你必须包含该计划中的所有相关上下文。

## 格式

格式和封装要求简单且严格。每个 ExecPlan 必须是一个标记为 `md` 的**单一围栏代码块（fenced code block）**，以三个反引号开始和结束。不要在内部嵌套额外的三反引号代码围栏；当你需要展示命令、记录、差异（diffs）或代码时，请在该单一围栏内使用**缩进块**呈现。为了清晰起见，请使用缩进而不是在 ExecPlan 内部使用代码围栏，以避免过早关闭 ExecPlan 的代码块。在每个标题后使用两个换行符，使用 `#` 和 `##` 等标记，并使用正确的语法编写有序和无序列表。

当将 ExecPlan 写入 Markdown (.md) 文件且文件内容**仅包含**该单一 ExecPlan 时，应省略三反引号。

用平实的散文写作。优先使用句子而不是列表。避免使用检查清单、表格和长篇大论的枚举，除非简洁会模糊原意。检查清单仅允许在 `Progress`（进度）部分使用，且在该部分是强制性的。叙述性部分必须保持以散文为主。

## 指南

**自包含和平实的语言至关重要**。如果你引入了一个非日常英语的短语（如 "daemon", "middleware", "RPC gateway", "filter graph"），请立即定义它，并提醒读者它在这个代码库中是如何体现的（例如，通过命名它出现的文件或命令）。不要说“如前定义”或“根据架构文档”。即使是重复，也要在这里包含所需的解释。

**避免常见的失败模式**。不要依赖未定义的行话。不要把“功能的字面意思”描述得太狭隘，导致生成的代码虽然能编译但没有任何意义。不要把关键决策推给读者。当存在歧义时，在计划本身中解决它，并解释为什么选择这条路径。与其详述无关紧要的实现细节，不如多花笔墨解释**用户可见的效果**。

**将计划锚定在可观察的结果上**。说明实现后用户可以做什么，运行的命令以及他们应该看到的输出。验收标准应表述为人类可验证的行为（“启动服务器后，访问 [http://localhost:8080/health](https://www.google.com/search?q=http://localhost:8080/health) 返回 HTTP 200 和内容 OK”），而不是内部属性（“添加了一个 HealthCheck 结构体”）。如果变更是内部的，解释如何演示其影响（例如，通过运行变更前失败而变更后通过的测试，并展示使用新行为的场景）。

**明确指定仓库上下文**。使用完整的仓库相对路径命名文件，精确命名函数和模块，并描述应在哪里创建新文件。如果涉及多个区域，包含一段简短的导向性段落，解释这些部分如何组合在一起，以便新手可以自信地导航。运行命令时，显示工作目录和确切的命令行。当结果取决于环境时，说明假设并在合理的情况下提供替代方案。

本仓库是 Electron + Vite 的前端工程，采用 npm workspaces 组织，核心代码位于 `packages/*`。编写 ExecPlan 时需明确具体包路径（例如 `packages/main/`、`packages/preload/`、`packages/renderer/`）以及对应的 npm 命令与工作目录。

**保持幂等性和安全性**。编写步骤时，确保它们可以多次运行而不会造成破坏或漂移。如果某个步骤可能中途失败，请包含如何重试或适应。如果必须进行迁移或破坏性操作，请详细说明备份或安全回退方案。优先选择增量式、可测试的变更，以便边做边验证。

**验证不是可选项**。包含运行测试、启动系统（如适用）并观察其执行有用操作的指令。描述针对任何新功能或能力的全面测试。包含预期的输出和错误消息，以便新手区分成功与失败。在可能的情况下，展示如何证明变更是有效的，而不仅仅是能编译通过（例如，通过一个小型的端到端场景、CLI 调用或 HTTP 请求/响应记录）。说明适合该项目工具链的确切测试命令以及如何解读其结果。

**保留证据**。当你的步骤产生终端输出、简短的 diff 或日志时，将它们作为**缩进示例**包含在这个单一围栏块中。保持简洁，专注于证明成功的内容。如果你需要包含补丁（patch），优先使用文件范围的 diff 或读者可以通过遵循你的指令重新创建的小片段，而不是粘贴大块的数据。

## 里程碑 (Milestones)

里程碑是叙事，而不是官僚主义。如果你将工作分解为里程碑，请用简短的段落介绍每一个里程碑，描述范围、里程碑结束时将存在哪些之前不存在的东西、要运行的命令以及你期望观察到的验收标准。像讲故事一样保持可读性：目标、工作、结果、证明。**进度（Progress）**和**里程碑（Milestones）**是不同的：里程碑讲述故事，进度追踪细粒度的工作。两者必须共存。永远不要为了简洁而缩写里程碑，不要遗漏对未来实现至关重要的细节。

每个里程碑必须是**独立可验证的**，并且增量地实现执行计划的总体目标。

## 动态计划与设计决策

* ExecPlans 是动态文档。当你做出关键设计决策时，更新计划以记录决策及其背后的思考。在 `Decision Log`（决策日志）部分记录所有决策。
* ExecPlans 必须包含并维护 `Progress`（进度）、`Surprises & Discoveries`（惊喜与发现）、`Decision Log`（决策日志）以及 `Outcomes & Retrospective`（结果与回顾）部分。这些不是可选项。
* 当你发现优化器行为、性能权衡、意外的 bug 或影响你方法的逆向/撤销语义时，在 `Surprises & Discoveries` 部分用简短的证据片段（测试输出是最理想的）记录这些观察结果。
* 如果你在实施中途改变方向，在 `Decision Log` 中记录原因，并在 `Progress` 中反映其影响。计划既是你工作的检查清单，也是下一个贡献者的指南。
* 在主要任务或整个计划完成时，写一段 `Outcomes & Retrospective` 条目，总结已取得的成果、遗留的差距和吸取的教训。

# 原型里程碑与并行实现

包含明确的原型里程碑来降低较大变更的风险是可接受的——通常也是鼓励的。例如：向依赖项添加底层算子以验证可行性，或在测量优化器效果的同时探索两种组合顺序。保持原型是增量且可测试的。清楚地将范围标记为“原型设计（prototyping）”；描述如何运行和观察结果；并说明推广或通过该原型的标准。

优先进行增量代码变更，然后进行删减，同时保持测试通过。并行实现（例如，在迁移期间保留适配器与旧路径共存）在能降低风险或使测试在大型迁移期间继续通过时是可以的。描述如何验证这两条路径以及如何通过测试安全地退役其中一条。当使用多个新库或功能区域时，考虑创建**技术探针（spikes）**，独立于彼此评估这些功能的可行性，证明外部库表现符合预期并在隔离状态下实现了我们需要的功能。

## 优秀 ExecPlan 的骨架

```md
# <简短的、以行动为导向的描述>

这份 ExecPlan 是一份动态文档。随着工作的进行，`Progress`、`Surprises & Discoveries`、`Decision Log` 和 `Outcomes & Retrospective` 章节必须保持更新。

如果 `PLANS.md` 文件已检入代码库，请在此处引用该文件相对于仓库根目录的路径，并注明本文档必须按照 `PLANS.md` 进行维护。

## Purpose / Big Picture (目的/大图景)

用几句话解释这次变更后某人能获得什么，以及他们如何看到它的运作。说明你将启用的用户可见行为。

## Progress (进度)

使用带复选框的列表来总结细粒度的步骤。每一个停止点都必须记录在这里，即使它需要将一个部分完成的任务拆分为两个（“已完成”与“剩余”）。本节必须始终反映工作的实际当前状态。

- [x] (2025-10-01 13:00Z) 示例已完成步骤。
- [ ] 示例未完成步骤。
- [ ] 示例部分完成的步骤（已完成：X；剩余：Y）。

使用时间戳来衡量进度速率。

## Surprises & Discoveries (惊喜与发现)

记录在实施过程中发现的意外行为、bug、优化或见解。提供简明的证据。

- 观察：...
  证据：...

## Decision Log (决策日志)

按以下格式记录在制定计划时做出的每一个决策：

- 决策：...
  理由：...
  日期/作者：...

## Outcomes & Retrospective (结果与回顾)

在主要里程碑或完成时，总结成果、差距和吸取的教训。将结果与最初的目的进行比较。

## Context and Orientation (背景与导向)

描述与此任务相关的当前状态，就好像读者什么都不知道一样。通过全路径命名关键文件和模块。定义你将使用的任何非显而易见的术语。不要引用以前的计划。

## Plan of Work (工作计划)

用散文描述编辑和添加的顺序。对于每个编辑，命名文件和位置（函数、模块）以及要插入或更改的内容。保持具体和最小化。

## Concrete Steps (具体步骤)

说明要运行的确切命令以及在哪里运行它们（工作目录）。当命令生成输出时，显示简短的预期记录，以便读者进行比较。本节必须随着工作的进行而更新。

## Validation and Acceptance (验证与验收)

描述如何启动或演练系统以及要观察什么。将验收表述为行为，包含具体的输入和输出。如果涉及测试，请说“运行 <项目的测试命令> 并预期 <N> 个通过；新的测试 <名称> 在变更前失败，在变更后通过”。

## Idempotence and Recovery (幂等性与恢复)

如果步骤可以安全重复，请说明。如果某个步骤有风险，请提供安全的重试或回滚路径。完成后保持环境清洁。

## Artifacts and Notes (工件与笔记)

作为缩进示例包含最重要的记录、差异（diffs）或代码片段。保持它们简洁，专注于证明成功的内容。

## Interfaces and Dependencies (接口与依赖)

具有指令性。命名要使用的库、模块和服务及其原因。指定里程碑结束时必须存在的类型、特征/接口和函数签名。

如果你遵循上述指导，一个单一的、无状态的智能体——或一个人类新手——可以从头到尾阅读你的 ExecPlan 并产生一个可工作的、可观察的结果。这就是标准：**自包含、自给自足、新手向导、结果导向**。

当你修改计划时，必须确保你的更改全面反映在所有章节中，包括动态文档部分，并且必须在计划底部写一条注释，描述更改的内容和原因。ExecPlans 几乎对所有事情不仅要描述“是什么”，还要描述“为什么”。

```
